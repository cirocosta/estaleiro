# estaleiro v0.0.2

Since the post that introduced [`estaleiro`][estaleiro] (see [A container image builder that (sort of) adheres to the metadata standard for OSL][pivotalk-post]), I got some updates to it and surrounding tooling that I used to develop it ([Concourse][concourse] and [`buildkit`][buildkit]), and `estaleiro` itself.

This marks the very second version of `estaleiro` - v0.0.2 -, with the following highlights:

<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->


- [out-of-tree package retrieval](#out-of-tree-package-retrieval)
- [non-ubuntu repositories](#non-ubuntu-repositories)
- [improved CI workflow](#improved-ci-workflow)
- [better buildkit graphs](#better-buildkit-graphs)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->


Coming next, I plan to start working on:

- scratch-based container images



[estaleiro]: https://github.com/pivotal/estaleiro
[buildkit]: https://github.com/moby/buildkit
[concourse]: https://concourse-ci.org
[dot]: https://www.graphviz.org/doc/info/lang.html
[pivotalk-post]: https://www.pivotalk.io/t/a-container-image-builder-that-sort-of-adheres-to-the-metadata-standard-for-osl/29655
[docker-image]: https://github.com/concourse/docker-image-resource
[builder-task]: https://github.com/concourse/builder-task
[registry-image]: https://github.com/concourse/registry-image-resource



## out-of-tree package retrieval

Differently from performing a `docker build` on a Dockerfile that installs a bunch of packages into a container image, `estaleiro` performs all of the debian packages and debian repositories interaction completely out of the chain of mutations that lead to the final container image.

For instance, with a definition

```hcl
image "my-final-image" {
  apt {
    package "vim" {}
  }
}
```

visually, that means something like:

![](https://user-images.githubusercontent.com/3574444/62842395-dd3ad680-bc7f-11e9-9a30-dd198a4221ac.png)



As all of those packages are just mounted, in the history of `FINAL_FS` there are no `.deb` packages at any point - just the result of their installation.

The benefit of doing it this way compared to in-tree builds is that we guarantee that we don't pollute the package dependency graph for the final image at any time.


## non-ubuntu repositories

Previously, any packages that were not part of the subset of Ubuntu repositories that we picked as default would not be possible to install.

That's because `estaleiro` used to just use the following `/etc/apt/sources.list`:

```
#                | FREE     | NON-FREE
#    ------------+----------+-----------
#      SUPPORTED | main     | restricted
#    -----------------------------------
#    UNSUPPORTED | universe | multiverse
#
deb http://archive.ubuntu.com/ubuntu/ bionic main restricted
deb-src http://archive.ubuntu.com/ubuntu/ bionic main restricted

deb http://archive.ubuntu.com/ubuntu/ bionic-updates main restricted
deb-src http://archive.ubuntu.com/ubuntu/ bionic-updates main restricted

deb http://archive.ubuntu.com/ubuntu/ bionic-security main restricted
deb-src http://archive.ubuntu.com/ubuntu/ bionic-secufity main restricted
```

Moving forward, `estaleiro` now allows you to specify repositories that are not part of such list.

For instance, consider Concourse's `docker-image-resource`, which relies on `docker-ce` coming from Docker's APT repository (and `jq` coming from Ubuntu's `universe` repository):


```
image "concourse/docker-image-resource" {
  base_image {
    name = "ubuntu"
    ref  = "bionic"
  }

  apt {
    repositories = [
      "deb http://archive.ubuntu.com/ubuntu/ bionic universe",
      "deb-src http://archive.ubuntu.com/ubuntu/ bionic universe",
      "deb https://download.docker.com/linux/ubuntu bionic stable",
    ]

    key "docker" {
      uri = "https://download.docker.com/linux/ubuntu/gpg"
    }

    package "ca-certificates" {}
    package "docker-ce" {}

    package "jq" {}
  }
}
```

To achieve that, two things were necessary to be worked on:

1. importing gpg keys to apt's keyring
2. supporting HTTPS repositories


### importing gpg keys

This one revealed quite interesting to me as I've never really dug deep into what `apt-key add -` really meant when I following installation guides on "the interwebz".


## improved CI workflow

Since at least the beginning of the year, the Concourse team has been pushing the idea of separating the [`docker-image`][docker-image] resource type in two:

- a task that does the container image building ([`builder-task`][builder-task])
- a resource type that deals with checking/fetching/pushing container images from/to registries ([`registry-image-resource`][registry-image])


```yaml
jobs:
- name: job
  plan:
    - get: repository
    - task: build
      privileged: true
      file: repository/ci/build.yml
    - put: container-image
      inputs: [image]
      params: {image: image/image.tar}
```

which then turns into


```


                  (builder)
              .---- task ------.
              |                |         (registry-image-resource)
              |                |             .---- put ----*
  repository -+- ./repository  |             |             |
  (from get)  |  ./image ------+-- image ----+- ./image    |
              |                |             |      |      |
              |                |             *------+------*
              *----------------*                    |
                                                    |
                                                    |
                    container image registry <------*
                  (dockerhub / gcr / docker-registry ... )


```

This has all to do with `estaleiro` because separation means that in order to have someone pushing images that have their bill of materials generated, all that they need to do is swap `builder` there, and let `registry-image-resource` take care of sending the generated container image to the registry configured.

```

                 (estaleiro)
              .---- task ------.
              |                |         (registry-image-resource)
              |                |             .---- put ----*
  repository -+- ./repository  |             |             |
  (from get)  |  ./image ------+-- image ----+- ./image    |
              |                |             |      |      |
              |                |             *------+------*
              *----------------*                    |
                                                    |
                                                    |
                    container image registry <------*
                  (dockerhub / gcr / docker-registry ... )

```

The problem though, is that the artifact that `buildkit` ends up producing under the hood




- https://github.com/concourse/registry-image-resource/issues/49


Previously, the only format that it supported was the traditional docker tarball format, where an image is described by the presence of a `manifiest.json` file, which describes the contents of the image (points to layers and the image configuration), like:


		0d315111b4847e.tar
		db8ee88ad75f6b.json
		0d315111b4847e/layer.tar -> ../0d315111b4847e.tar
		0d315111b4847e/VERSION
		0d315111b4847e/json
		manifest.json


	Now, with the PR in, we'd allow the consumption of the OCI archives and
	directory structures that adhere to the OCI image layout standard:


		blobs/
		blobs/sha256/
		blobs/sha256/578ef453bf13f0
		blobs/sha256/d068e40b116fa9
		blobs/sha256/ee153a04d68370
		index.json
		oci-layout

	Something interesting about such format is that the `index.json` that
	you see there can reference multiple images, which makes a lot of sense
	to do when building for multiple platforms (e.g., `amd64`, `armv7`,
	`armv8`, etc).

	ps.: I've written about how I was able to run Concourse workers with
	full containerizeation on ARMv7 and ARMv8 here:
	https://ops.tips/blog/raspberry-pi-concourse-ci-worker/



	* PR for `registry-image-resource` to allow the consumption of OCI image
	layout tarballs / directories

		- still not 100% DockerHub does not allow one to leverage plain
		  OCI media types :( this means that you have to use either your
		  own registry, or GCR / Azure which accept OCI.



## better buildkit graphs

Previously, when converting the intermediary representation (LLB) that `estaleiro` produces to a [dot-notation][dot] graph, we'd not be able to see operations that involved file manipulation between states (e.g., `copy`ing files).

This made the process of debugging hard as having to rely on the `json` representation was not very pleasant.


- https://github.com/moby/buildkit/pull/1110

